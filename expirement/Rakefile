# TODO pull "exp_described.yml" to constant variable 
#

#
# For loading yaml parameter files
require 'yaml'

# Remotely Execute a command using slurm.
def rSh(name, command, slurm_hash)
	salloc_commands = "" 

	slurm_hash.each do |arg,val|
		salloc_commands << "--#{arg.to_s} #{val} "
	end

	myCommand = "salloc -J #{name} #{salloc_commands} \
srun #{command}"

	# Echo Command
	puts myCommand
	# Run Command
	sh   myCommand
end


task :test do |t|
	rSh "index", "aeou", :mem=>"100m", :foo=>"bar"
end

#Genome class

class Genome 
	include Rake::DSL

	attr_reader :name, :yml_file, :pre, :dir, :fa, :gtf, :idx_dir, :idx_log, :bowtie_pre, :yml
	def initialize(name)
		# Checks to make sure genome exists
		#
		@name       = name 
		@yml_file   = "genomes/#{@name}.yml"             #Genome Yml

		unless File.exist? ( "genomes/#{name}.yml" )
			raise "Genome Does not exist"
		end 

		@pre        = "genomes/#{@name}" 
		@dir        = "#{@pre}/"                #Genome Directory
		@fa         = "#{@pre}/genome.fa"       #Genome fasta location
		@gtf        = "#{@pre}/transcripts.gtf" #Transcript gtf location
		@idx_dir    = "#{@pre}/genome_idx/"     #Bowtie2 Index for Genome
		@idx_log    = "#{@pre}/genome_idx/log"  #Bowtie2 Index Log
		@bowtie_pre = "#{@pre}/genome_idx/p"    #Bowtie2 Genome Pre
		@yml        = YAML.load_file( @yml_file)

		@master_task= "genome_#{name}"

		rules
	end

	def rules
		desc "Create genome directory"
		directory dir

		desc "Download Genome #{@name} Fasta"
		file fa => [yml_file, dir]  do |t|
			genome_fasta_url = yml["genome_fasta"]

			unzip = File.extname(genome_fasta_url) == ".gz" ? "| gunzip -c" : "" 

			sh "wget -O - #{genome_fasta_url} #{unzip} > #{t.name}"
		end

		desc "Download Genome #{@name} GTF"
		file gtf => [yml_file, dir] do |t|

			genome_gtf_url = yml["transcript_gtf"]

			#splice additional command to zip if it's zipped 
			unzip = File.extname(genome_gtf_url) == ".gz" ? "| gunzip -c" : "" 
			sh "wget -O - #{genome_gtf_url} #{unzip} > #{t.name}"
		end

		desc "Create Genome Idx Dir"
		directory idx_dir

		desc "Index the genome using Bowtie 2"
		file idx_log => [fa, idx_dir] do |t| 

			rSh "bowtie2-build", "bowtie2-build #{fa} #{idx_dir}p > #{idx_log}", :mem=>"8000m"

		end

		task "genome_#{name}" => [idx_log, gtf]
	end
end

Genome.new("ZV9")

class Expirement
	include Rake::DSL
	attr_reader :sample_dir, :dir, :name

	def initialize(expirement_name)

		@name = expirement_name
		@dir = "expirements/#{@name}"
		@yml_file = "#{@dir}/exp_described.yml"
		@sample_dir = "#{@dir}/samples"
		@samplesheet = "#{@dir}/samplesheet"
		@yml = YAML.load_file @yml_file

		directory @sample_dir

		@conditions = @yml['conditions'].map do |c|
			Condition.new(self, c)
		end

		sample_sheet_rule

	end

	def sample_sheet_rule
		desc "Generate Expirement Sample Sheet"
		file @samplesheet => @yml_file do 
			File.open(@sample_sheet, 'w') { |file| 
				@conditions.each do |c|
					c.replicates.each do |r| 
						file.write "#{r.alignment}\t#{c.name}\n"
					end
				end
			}
		end
	end

end

class Condition
	include Rake::DSL
	attr_reader :dir, :replicates, :name
	def initialize(expirement,condition_yml)
		puts expirement.dir
		@expirement = expirement
		@name = condition_yml['name']
		@dir = "#{@expirement.sample_dir}/#{@name}"

		# Create Rule for condtion_dir
		directory @dir

		@replicates = condition_yml['replicates'].map do |r|
			Sample.new(@expirement,self,r)
		end

	end

end

class Sample
	include Rake::DSL
	attr_reader :dir, :alignment

	def initialize(expirement, condition, desc_hash)
		@expirement = expirement
		@condition = condition
		@id        = desc_hash['id']
		@r1_samples = desc_hash['r1'] 
		@r2_samples = desc_hash['r2'] if desc_hash.key? 'r2'
		@dir        = "#{@condition.dir}/#{@id}"
		@alignment  = "#{@dir}/accepted_hits.bam"

		directory @dir

		puts to_s

	end

	def to_s 
		"#{@expirement.name}_#{@condition.name}_#{@id}"
	end

end

Expirement.new("brain_mehg")

=begin
expirement_dirs=FileList.new("expirements/*")

expirement_dirs.each do |exp_dir| 

	exp_name = File.basename exp_dir

	# Load Expirement YAML
	exp_yml_file = "#{exp_dir}/exp_described.yml"

	# Make Sure Descriptor File Exists
	exp_desc = YAML.load_file exp_yml_file

	task "build_#{exp_name}_skeleton" => exp_yml_file do |t|
		sample_dir = "#{exp_dir}/samples"
		Dir.mkdir ( sample_dir ) unless Dir.exists?( sample_dir )

		# Condition Directory
		exp_desc['conditions'].each do |c| 
			cond_dir = "#{sample_dir}/#{c['name']}"
			Dir.mkdir ( cond_dir ) unless Dir.exists? ( cond_dir )

			# Relicate Directory
			c['replicates'].each do |rep| 
				rep_dir = "#{cond_dir}/#{rep['id']}"
				Dir.mkdir ( rep_dir ) unless Dir.exists? ( rep_dir )

				# Link Data Files
				# TODO actually link files
			
				File.write "#{rep_dir}/r1.fq.gz", ""
				File.write("#{rep_dir}/r2.fq.gz","") if rep.key?("r2")

			end

		end

	end
	
	desc "Generate cufflink sample sheet from exp_described file" 
	task "#{exp_dir}/sample_sheet" => exp_yml_file do t 
		File.open( t.name ) |file| do
			exp_desc['conditions'].each do |c| 
				c['replicates'].each do |rep| 


		end

	end

end


# Sequencer/Sequencing Related Information is dynamically stored in modules.

# Or we can use a factory 

module IlluminaTruSeq


end

# Expirement Class encodes the expirement with helper funcitons.
class Expirement

	def initialize (exp_described)
		

		@conditions 
	end
 
	# Expirements have many conditions
	class Condition
		def initialize (args)

		end
		
		# Conditions have many replicates
		class Replicate
			def initialize (args)

			end

			# TODO Returns the filepaths of the initial read files as an array
			def raw_read_files

			end

			# TODO Returns the filepaths of the cleaned read files as an array
			def cleaned_read_files

			end

			# TODO Return a hash with the adapter sequences.
			def adapter_sequence

			end
		end
	end
end
=end
